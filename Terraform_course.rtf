{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sl240\slmult1\f0\fs20\lang9\par
Terraform's primary function is to create, modify and destroy infrastructure resources to match the desired state described in terraform configuration\par
Desired state  - in terraform config  *.tf file (if empty - terraform will remove all (in accordance with terraform.tfstate file))\par
Current state - is the actual state of a resource that is currently deployed\par
If there is a difference between these two states - "terraform plan" command will present a description of the neccessary changes\par
\par
Important - what is not described in .tf file is not counted for a difference  (e.g - if SG is not described as a part of desired state of EC2 resource in .tf file then even changed in AWS console will not impact a TF plan (but a plan itself will be updated accordingly with new SG (terraform refresh)))\par
Then, always specify ALL important parameters of the resource in .tf file\par
\par
Resource behavior - {{\field{\*\fldinst{HYPERLINK https://developer.hashicorp.com/terraform/language/resources/behavior }}{\fldrslt{https://developer.hashicorp.com/terraform/language/resources/behavior\ul0\cf0}}}}\f0\fs20\par
Some details of that behavior can be customized using the special nested LIFECYCLE block (lifecycle Meta-Argument) within a resource block body (find examples below).\par
\par
instead of running one big .tf file make many  .tf files each having one thing to care about, like providers.tf ec2_instances.tf iam_users.tf variables.tf terraform.tfvars  (everything in the same dir)\par
\par
Authentication and Authorization\par
============================\par
\par

\pard\sa200\sl276\slmult1 Main rule - look in documentation for each provider under "Authentication" part, like for aws provider {{\field{\*\fldinst{HYPERLINK https://registry.terraform.io/providers/hashicorp/aws/latest/docs }}{\fldrslt{https://registry.terraform.io/providers/hashicorp/aws/latest/docs\ul0\cf0}}}}\f0\fs20  --> Authentication and Configuration\par

\pard\sl240\slmult1 Usage:\par
provider "aws" \{\par
  region     = "us-west-2"\par
  access_key = "my-access-key"\par
  secret_key = "my-secret-key"\par
\}\par
\par
The AWS Provider can source credentials and other settings from the shared configuration and credentials files. By default, these files are located at \par
$HOME/.aws/config\par
$HOME/.aws/credentials \par
on Linux and macOS,\par
and "%USERPROFILE%\\.aws\\config" and "%USERPROFILE%\\.aws\\credentials" on Windows.\par
and it is the same default location that be configured by running AWS CLI command "aws configure". In that case no need to mention this in TF provider conf block above.\par
\par
The locations of the shared configuration and credentials files can be configured using either the parameters shared_config_files and shared_credentials_files\par
\par
For example:\par
provider "aws" \{\par
  shared_config_files      = ["/Users/tf_user/.aws/conf"]\par
  shared_credentials_files = ["/Users/tf_user/.aws/creds"]\par
  profile                  = "customprofile"\par
\}\par
\par
\par
Providers and Resources\par
====================\par
Official (of hashicorp)\par
Partner\par
Community \par
\par
For example, we can consider a resource like this:\par
\par
resource "aws_instance" "example" \{\par
  # ...\par
\}\par
\par

\pard\ri-732\sl240\slmult1\tx8662\tx9372 If you haven't declared what provider you mean by aws then Terraform will assume that you mean to write something like this:\par
\par

\pard\sl240\slmult1 terraform \{\par
  required_providers \{\par
    aws = \{\par
      source = "hashicorp/aws"\par
      version = '~> 3.0'  #default - latest version, maybe >=1.0 <=1.0 or both, means between\par
    \}\par
  \}\par
\}\par
\par
Block "required_providers" is essential for Partner\\Community providers\par
\par
*Provider plugin version is locked by .terraform.lock.hcl file at very first time it was downloaded by running terraform init - maybe deleted if you want to change provider version (if it was loacked at 4.62 and now there is version 4.8)\par
Another way is to put exact version in tf file and then run "terraform init -upgrade"\par
\par
Comment a block in Terraform\par
=========================\par
/*\par
*/\par
If a code is commented out in config some.tf file, next time terraform plan / apply will be running it assumes that there is no such code (= deleted) and will destroy it if exists\par
# (// - same as hash) - single line\par
 \par
Terraform state file (terraform.tfstate)\par
================================\par
Stores the state of the infrastructure created from .tf file\par
This state allows terraform to map resource in a remote system (real world) and resource declared in your configuration (.tf file)\par
If terraform.tfstate is removed (losing state) then Terraform loses track of the infrastructure that exists. If that is lost, it will try to delete things that shouldn't be deleted or, more likely, create things that already exist.\par
Make sure you always have a backup of this file!\par
Never modify state file directly but make use of "terraform state" command\par
\par
terraform.tfstate file gets updated only after "terraform apply" command was ran\par
\par
Terraform settings\par
================\par
terraform \{\par
  required_version = "< 0.11"\par
  required_providers \{\par
    aws = "~> 2.0"\par
  \}\par
\par
Terraform COMMANDS\par
====================\par
- Debbuging:\par
set var TF_LOG=TRACE (DEBUG,INFO,WARN,ERROR)\par
temporally: export TF_LOG=TRACE (export TF_LOG_PATH=/tmp/tfout.log)\par
\par
- terraform fmt   #  will properly format .tf file in the same dir\par
- terraform validate # will validate .tf file (including undeclaring vars etc)\par
\par
- terraform refresh  # shouldn't be used explicitly because TF automatically perform refreshing as a part of tf plan and tf apply commands.\par
Running manually is pretty dangerous because refresh command may remove some (or all) resources described in terraform.tfstate file (e.g. if change was done in .tf file before refresh)\par
\par
- terraform plan -refresh=false #prevent TF from querying the current state\par
- terraform plan -target=resource (e.g. ec2) #target only specified resource and isolate the rest. Useful in case only one resource was changed\par
\par
- terraform plan -out path=tfconf_backup (will be saved as binary file) and then you can run apply based on this file\par
terraform apply tfconf_backup\par
\par
- terraform apply -auto-approve\par
- terraform apply -replace="aws_instance.webserver" (in old TF versions "terraform taint")\par
#will destroy and then create the resource from scratch as described in .tf file even there was no change in the resource for TF (e.g. changes were made manually)\par
\par
- terraform state (list, mv(=rename resorce), rm(deleted resorce is not physically removed), pull(output if remote state file) )\par
\par
- terraform ouput iam_names # is used to extract the value of output var from terraform.tfstate file\par
\par
- terraform graph - will generate a visual representation  of .tf configuration (needs additional tools and installations)\par
\fs22\par
\fs20 - terraform import - will bring manually created resorces into TF (both resources.tf and terraform.tfstate files will be created)\par
Use"import" block in .tf file.\fs22\par
then run "terraform  plan -generate-config-out=mynewconf.tf"\par
\par
\fs20 EXAMPLES\par
=========\par
\par
** VARIABLES **\par
==============\par
{{\field{\*\fldinst{HYPERLINK https://developer.hashicorp.com/terraform/language/values/variables#variable-definition-precedence }}{\fldrslt{https://developer.hashicorp.com/terraform/language/values/variables#variable-definition-precedence\ul0\cf0}}}}\f0\fs20\par
\par
The name of a variable can be any valid identifier except the following: source, version, providers, count, for_each, lifecycle, depends_on, locals.\par
\par
Create variables.tf  file with vars inside like :\par
variable "elb_ip" \{\par
  default = 10.20.30.40\par
\}\par
variable "instance_type" \{\par
  default = "t2.micro"\par
\}\par
# If a default value is not defined that tf plan \\ tf apply will ask you for this value\par
\par
and in config .tf file use variable name like:  \par
cidr_blocks = var.vpn_ip\par
\par
You may use variables.tf  along with terraform.tfvars \par
In variables.tf :  variable "instance_type" \{\}\par
In terraform.tfvars: instance_type="t2.large"\par
If instead of In terraform.tfvars use custom name: terraform plan -var-file="custom.tfvars"\par
\par
Setting a var with a command wil take priority of a value in variables.tf:\par
terraform plan -var="instance_type=t2.small"\par
\par
Another way use as ENV VAR: (linux) export TF_VAR_instance_type="t2.large"\par
\par
var name can be defined in .tf file but then you yet need set up the var itself in terraform.tfvars\par
\par
VARIABLES DATA TYPES\par
--------------------------------\par
variables.tf (it is best practice to define a type for each var):\par
variable "elb_name" \{\par
  type = string\par
\}\par
variable "az" \{\par
  type = list\par
\}\par
variable "timeout" \{\par
  type = number\par
\}\par
variable "ec2_types" \{\par
  type = map\par
  default = \{\par
      us-west-1 = "t2.micro"\par
      us-west-2 = "t2.nano"\par
   \}\par
\}\par
\par
terraform.tfvars:\par
elb_name="myelb"                 #type string\par
az=["us-west-1","us-west-2"] #list\par
timeout=60                              #number\par
\par
config .tf:\par
instance_type = var.ec2_types[us-west-1]\par
OR\par
instance_type = var.ec2_list[0]\par
\par
CONDITIONAL expressions in .tf work with var as well:\par
----------------------------------------------------------------------\par
\par
provider "aws" \{\par
 \}\par
\par
variable "istest" \{\} # set up this var as conditional expression\par
#and in in terraform.tfvars give the value, like "istest = true"\par
\par
resource "aws_instance" "dev" \{\par
   ami = "ami-082b5a644766e0e6f"\par
   instance_type = "t2.micro"\par
   count = var.istest == true ? 3 : 0 #meaning if var.istest is true create 3 if not (false) then 0\par
\}\par
\par
resource "aws_instance" "prod" \{\par
   ami = "ami-082b5a644766e0e6f"\par
   instance_type = "t2.large"\par
   count = var.istest == false ? 1 : 0  #meaning if var.istest is false create 1 if not (true) then 0\par
\}\par
\par
\lang1033 ** CROSS RESOURCES Attribute References **\par
======================================\par
Go to Documentation of desired Provider --> choose Resource and look for "Attribute Reference" list here (present for each resource)\par
\par
resource "aws_instance" "myec2" \{\par
   ami = "ami-082b5a644766e0e6f"\par
   instance_type = "t2.micro"\par
\}\par
\par
resource "aws_eip" "lb" \{\par
  vpc      = true\par
\}\par
\par
resource "aws_eip_association" "eip_assoc" \{\par
  instance_id   = aws_instance.myec2.id\par
  allocation_id = aws_eip.lb.id\par
\}\par
\par
\par
resource "aws_security_group" "allow_tls" \{\par
  name        = "kplabs-security-group"\par
\par
  ingress \{\par
    from_port   = 443\par
    to_port     = 443\par
    protocol    = "tcp"\par
    cidr_blocks = ["$\{aws_eip.lb.public_ip\}/32"]\par
\par
\lang9\par
\par
**  OUTPUT Values **\par
==================\par
\par
To get a value output on a screen while running tf apply use "output" block\par
\lang1033\par
resource "aws_eip" "lb" \{\par
  vpc      = true\par
\}\par
\lang9 # running this you will get a standard output:  \lang1033 aws_eip.lb will be created and each attribute will get "= (known after apply)\par
\par
Adding this block:\par
output "public-ip" \{\par
   value =  "aws_eip.lb.public_ip\par
\}\par
#public_ip is from a list of "Attribute Reference" of the resource. Without specifying an attribute  ALL attributes of the resource will be presented\par
The same you will find in terraform.tfstate file under "outputs"/"name of your output block"\par
\par
\lang9 will get \par
Outputs:\par
public-ip = " real IP of created resource"\par
as a part of terraform apply command.\par
\par
Can use a substituation as well:\par
\lang1033 output "public-ip" \{\par
   value =  "{{\field{\*\fldinst{HYPERLINK https://$(aws_eip.lb.public_ip):8080 }}{\fldrslt{https://$(aws_eip.lb.public_ip):8080\ul0\cf0}}}}\f0\fs20 "\par
\}\par
\par
OR use with "count" (splat expressions): \par
output "arns" \{\par
  value = aws_iam_user.lb[*].arn\par
\}\par
output "arns" \{\par
  value = aws_iam_user.lb[*].name\par
\}\par
\par
To make a map (key=value pair) out of these outputs add zipmap function at the end:\par
output "combined_outputs" \{\par
  value = zipmap(aws_iam_user.lb[*].name, aws_iam_user.lb[*].arn)\par
\}\par
\par
use "sensitive = true" in case pf password etc (the vbalue will be not displayed in CLI but in terraform.tfstate file)\par
\par
\par
** COUNT Parameter **  \par
====================\par
resource "aws_instance" "instance-1" \{\par
   ami = "ami-082b5a644766e0e6f"\par
   instance_type = "t2.micro"\par
   count = 3\par
\}   #three ec2 instances will be created from this AMI\par
\par
#This config will create 3 users with unique names from the list\par
provider "aws" \{\par
  region     = "us-west-2"\par
\}\par
variable "elb_names" \{\par
  type = list\par
  default = ["dev-loadbalancer", "stage-loadbalanacer","prod-loadbalancer"]\par
\}\par
resource "aws_iam_user" "lb" \{\par
  name = var.elb_names[count.index]\par
  count = 3\par
  path = "/system/"\par
\}\par
\par
\par
**LOCAL values**\par
===============\par
Terraform local values (or "locals") assign a name to an expression or value. Using locals simplifies your Terraform configuration \f1\endash  \f0 since you can reference the local multiple times, you reduce duplication in your code. \par
\par
locals \{\par
  common_tags = \{\par
    Owner = "DevOps Team"\par
    service = "backend"\par
  \}\par
\}\par
resource "aws_ebs_volume" "db_ebs" \{\par
  availability_zone = "us-west-2a"\par
  size              = 8\par
  tags = local.common_tags\par
\}\par
\lang9\par
\lang1033 Use "local" instead of "var" when you want a value being put in one cenralized place (like any var) but with no option to overwrite it (as it possible with var - you set default value with var which can be overwritten)\par
Especially with modules.\par
\par
-- This is how to overwrite var default value:\par
variables.tf:\par
variable "app_port" \{\par
  default - "8444"\par
\}\par
\par
conf.tf:\par
module "sg_module" \{\par
  source = "path/sg"\par
  app_port = 22               # will take place\par
\}\par
\par
-- NOT overwritable value with local (In "Module" config file):\par
resource "aws_security_group" "ec2-sg" \{\par
  name        = "myec2-sg"\par
\par
  ingress \{\par
    description      = "Allow Inbound from Secret Application"\par
    from_port        = local.app_port\par
    to_port          = local.app_port\par
    protocol         = "tcp"\par
    cidr_blocks      = ["0.0.0.0/0"]\par
  \}\par
\par
locals \{\par
  app_port = 8444\par
\}\par
\lang9\par
\par
\lang1033 **FUNCTIONS**      (only built-in functions are available for use)\par
==============\par
{{\field{\*\fldinst{HYPERLINK https://developer.hashicorp.com/terraform/language/functions }}{\fldrslt{https://developer.hashicorp.com/terraform/language/functions\ul0\cf0}}}}\f0\fs20\par
\par
\par
**DATA SOURCE code**\par
====================\par
The same resource may have different ID in different regions, e.g AMI of AWS. Instead of hard-coding AMI id for each region use data block with filter with owners (amazon/self etc), name and value\par
\par
data "aws_ami" "app_ami" \{\par
  most_recent = true\par
  owners = ["amazon"]\par
\par
  filter \{\par
    name   = "name"\par
    values = ["amzn2-ami-hvm*"]\par
  \}\par
\}\par
# {{\field{\*\fldinst{HYPERLINK https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-instances.html }}{\fldrslt{https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-instances.html\ul0\cf0}}}}\f0\fs20   about --filters option\par
\par
resource "aws_instance" "instance-1" \{\par
    ami = data.aws_ami.app_ami.id\par
   instance_type = "t2.micro"\par
\}\par
\lang9\par
\lang1033 ** DYNAMIC blocks (for_each)**\par
===========================\par
{{\field{\*\fldinst{HYPERLINK https://developer.hashicorp.com/terraform/language/expressions/dynamic-blocks }}{\fldrslt{https://developer.hashicorp.com/terraform/language/expressions/dynamic-blocks\ul0\cf0}}}}\f0\fs20\par
Terraform dynamic blocks are a special Terraform block type that provide the functionality of a for expression by creating multiple nested blocks. \par
variable "sg_ports" \{\par
  type        = list(number)\par
  description = "list of ingress ports"\par
  default     = [8200, 8201,8300, 9200, 9500]\par
\}\par
\par
resource "aws_security_group" "dynamicsg" \{\par
  name        = "dynamic-sg"\par
  description = "Ingress for Vault"\par
\par
  dynamic "ingress" \{\par
    for_each = var.sg_ports\par
    iterator = port\par
    content \{\par
      from_port   = port.value\par
      to_port     = port.value\par
      protocol    = "tcp"\par
      cidr_blocks = ["0.0.0.0/0"]\par
    \}\par
  \}\par
\par
  dynamic "egress" \{\par
    for_each = var.sg_ports\par
    content \{\par
      from_port   = egress.value\par
      to_port     = egress.value\par
      protocol    = "tcp"\par
      cidr_blocks = ["0.0.0.0/0"]\par
    \}\par
  \}\par
\}\par
\par
#another example with "toset" function\par
resource "aws_iam_user" "iam" \{\par
  for_each = toset( ["user-01","user-02", "user-03"] )\par
  name     = each.key\par
\}\par
\par
**Changing default resource behavior with LifeCycle Meta-Argument\par
==========================================================\par
The arguments available within a lifecycle block are \par
create_before_destroy, prevent_destroy, ignore_changes, and replace_triggered_by.\par
\par
To IGNORE manually made changes in infra (here -tags) - add in the resource block:\par
lifecycle \{\par
       ignore_changes = [tags]\par
\}\par
\par
\par
** Provisioners**\par
==============\par
{{\field{\*\fldinst{HYPERLINK https://developer.hashicorp.com/terraform/language/resources/provisioners/syntax }}{\fldrslt{https://developer.hashicorp.com/terraform/language/resources/provisioners/syntax\ul0\cf0}}}}\f0\fs20\par
\lang9\par
You can use provisioners to model specific actions on the local machine or on a remote machine in order to prepare servers or other infrastructure objects for service.\par
\par
"file" provisoner\par
{{\field{\*\fldinst{HYPERLINK https://developer.hashicorp.com/terraform/language/resources/provisioners/file }}{\fldrslt{https://developer.hashicorp.com/terraform/language/resources/provisioners/file\ul0\cf0}}}}\f0\fs20\par
# Copies the string in content into /tmp/file.log\par
  provisioner "file" \{\par
    content     = "ami used: $\{self.ami\}"\par
    destination = "/tmp/file.log"\par
  \}\par
\par
"remote-exec"  (to run command on remote server itself \par
{{\field{\*\fldinst{HYPERLINK https://developer.hashicorp.com/terraform/language/resources/provisioners/remote-exec }}{\fldrslt{https://developer.hashicorp.com/terraform/language/resources/provisioners/remote-exec\ul0\cf0}}}}\f0\fs20\par
{{\field{\*\fldinst{HYPERLINK https://developer.hashicorp.com/terraform/language/resources/provisioners/connection }}{\fldrslt{https://developer.hashicorp.com/terraform/language/resources/provisioners/connection\ul0\cf0}}}}\f0\fs20\par
  # Establishes connection to be used by all\par
  # generic remote provisioners (i.e. file/remote-exec)\par
  connection \{\par
    type     = "ssh"\par
    user     = "root"\par
    password = var.root_password\par
    #private_key = key.pem of the remote server\par
    host     = self.public_ip\par
  \}\par
\par
  provisioner "remote-exec" \{\par
    inline = [\par
      "command 1",\par
      "command 2",\par
    ]\par
  \}\par
\}\par
\par
"local-exec" (to run command from TF server after resource is created --> for running Ansible playbook)\par
{{\field{\*\fldinst{HYPERLINK https://developer.hashicorp.com/terraform/language/resources/provisioners/local-exec }}{\fldrslt{https://developer.hashicorp.com/terraform/language/resources/provisioners/local-exec\ul0\cf0}}}}\f0\fs20\par
\par
\par
TF backends and State File locking\par
============================\par
{{\field{\*\fldinst{HYPERLINK https://developer.hashicorp.com/terraform/language/settings/backends/configuration }}{\fldrslt{https://developer.hashicorp.com/terraform/language/settings/backends/configuration\ul0\cf0}}}}\f0\fs20\par
A backend defines where Terraform stores its state data files.\par
Default - local backend\par
When TF executes "write" operation (apply/destroy) the terraform.tfstate is locked and another "write" operation will fails with error "Error acquiring the state lock" (NOT ALL backends support StateFile locking make sure you has one when working in team)\par
\par
TF has "force-unlock" command to manually unlock the state\par
When state locked the terraform.tfstate.lock.info file is created. the file has info about lock ID, who and when executes write operation. Once unlocked - file gets deleted\par
\par
DynamoDB with S3 backend for state locking - one of useful implementation\par
\par
\par
Resorces in multiple Regions (AWS)\par
==============================\par
# If you have more that 1 same providers use "alias" in providers.tf\par
provider "aws" \{\par
  region     =  "us-west-1"\par
\}\par
\par
provider "aws" \{\par
  alias      =  "aws02"\par
  region     =  "ap-south-1"\par
  profile    =  "account02"\par
\}\par
\par
And then resource will point to the alias \par
resource "aws_eip" "myeip01" \{\par
  vpc = "true"\par
  provider = "aws.aws02"\par
\}\par
\par
Resorces in multiple accounts (AWS)\par
==============================\par
\par
in .aws/credentials files\par
[default]\par
aws_access_key_id=\par
aws_secret_access_key=\par
[account02]\par
aws_access_key_id=\par
aws_secret_access_key=\par
\par
and then add to providers.tf "profile" parameter - see in example above\par
\par
\par
\par
\par
\par
\par
}
 